// MIH_LINK_SAP.cpp

#include "MIH_LINK_SAP.h"
//#include "mac_dot16.h"
//#include "mac_dot16_ss.h"
//#include "api.h"






/* OANA BARBU */ 


/*Link_Parameters_Report indicates changes in link conditions that have crossed specified threshold levels.
Link_Parameters_Report is also generated at specified intervals for various parameters.
In case of 802.11 network, this event is generated when higher protocol layers wish to monitor the performance
parameters for a network. These higher layers can be on the network side (for network initiated handovers)
and MIHF on the local MN can transfer these parameters. For local MN initiated handovers, the
local station management entity (SME) and MSGCF would monitor link layer properties and the MIHF
would normally be interested only in the Link_Going_Down.indication.*/



/*included in api.h MSG_MAC_Link_Parameters_Report_indication */
void Link_Parameters_Report_indication(
		Node*            	node,
		LINK_TUPLE_ID*    	LinkIdentifier,
		L_LINK_PARAM_RPT* 	LinkParametersReportList,
		NodeAddress 		destinationAddress,
		unsigned char*		poaId)
{
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
                MIH_PROTOCOL,
                MSG_MAC_Link_Parameters_Report_indication);

   
    MESSAGE_InfoAlloc(node, newMsg, sizeof(param_signal));
    param_signal* param = (param_signal *)MESSAGE_ReturnInfo(newMsg);

//    newNode->phyData = (PhyData **) MEM_malloc(sizeof(PhyData*) * MAX_NUM_PHYS);
//        assert(newNode->phyData != NULL);
//        memset(newNode->phyData, 0, sizeof(PhyData*) * MAX_NUM_PHYS)

    unsigned char *temp =  (unsigned char *) MEM_malloc(sizeof(unsigned char)*6);

    temp = poaId;

//    param->poaId = &poaId;
    param->linkParamRptList = LinkParametersReportList;
	param->linkId = LinkIdentifier;
	param->dest = destinationAddress;
	for (int j=0; j<=5;j++)
		param->poaId[j]=temp[j];
//	MEM_Free(temp);
    MESSAGE_Send(node, newMsg, 0);
};



/*Link_Detected indicates the presence of a new PoA. This implies that the MN is in the coverage area.
Link_Detected does not guarantee that the MN will be able to establish connectivity with the detected link,
but just that the MN can attempt to gain connectivity. MIH Users and the MIHF evaluate additional properties
of the link before attempting to establish an L2 connection with the link. Moreover, Link_Detected is
not generated when additional PoAs of the same link are discovered. In case of 802.11, Link_Detected is
generated by MAC state generic convergence function (MSGCF).*/
void Link_Detected_indication (
       Node*            node,
       LINK_DET_INFO* LinkDetectedInfo/*,
	 NodeAddress destinationAddress*/)
{
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
                MIH_PROTOCOL,  
                MSG_MAC_Link_Detected_indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(new_network));
    new_network *link_detected = (new_network *)MESSAGE_ReturnInfo(newMsg);
	//network's new id 
	link_detected->network_id=LinkDetectedInfo->nid ;
	//sending info about the strength of the signal:
	link_detected->signal_strength = LinkDetectedInfo->ss;
    //link_detected->dest=destinationAddress;
    MESSAGE_Send(node, newMsg, 0);
};




/*This notification is delivered when a layer 2 connection is established on the specified link interface. All
layer 2 activities in establishing the link connectivity are expected to be completed at this point of time.*/
void Link_Up_indication(
		Node*            node,
		LINK_TUPLE_ID*    LinkIdentifier,
		LINK_ADDR*        OldAccessRouter,
		LINK_ADDR *       NewAccessRouter,
		IP_RENEWAL_FLAG  IpRenewalFlag,
		IP_MOB_MGMT      MobilityManagementSupport/*,
		NodeAddress		destAddress*/)
{
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
              MIH_PROTOCOL,  
                MSG_MAC_Link_Up_indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_up_str));
    link_up_str *up = (link_up_str *)MESSAGE_ReturnInfo(newMsg);

    //sending the router's mac address of type TRANSPORT_ADDR
	//up->Router_MAC_Address=NewAccessRouter->value.ma;
	//sending the link's id of type link_id

    up->LinkIdentifier=LinkIdentifier;
    up->OldAccessRouter=OldAccessRouter;
    up->NewAccessRouter=NewAccessRouter;
    up->IpRenewalFlag=IpRenewalFlag;
    up->MobilityManagementSupport= MobilityManagementSupport;
	up->dest = node->nodeId;
	
	MESSAGE_Send(node, newMsg, 0);
};


/*This notification is delivered when a layer 2 connection is no longer available for sending frames, that is,
when the L2 connection with network is terminated and not during PoA to PoA transitions for the same network */
void Link_Down_indication(
Node*            node,
		LINK_TUPLE_ID*    LinkIdentifier,
		LINK_ADDR*        OldAccessRouter,
		LINK_DN_REASON   ReasonCode/*,
		NodeAddress destinationAddress*/)
{
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
                MIH_PROTOCOL,
                MSG_MAC_Link_Down_indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_down_str));
    link_down_str *down = (link_down_str *)MESSAGE_ReturnInfo(newMsg);
    down->LinkIdentifier=LinkIdentifier;
	down->OldAccessRouter=OldAccessRouter;
    down->ReasonCode=ReasonCode;
	MESSAGE_Send(node, newMsg, 0);
};

/**/



/*BOGDAN CIOBOTARU*/

/* to be included in api.h because they were not previously defined:
	MSG_MAC_Link_PDU_Transmit_Status_indication,
	MSG_MAC_Link_Capability_Discover_confirm,
	MSG_MAC_Link_Event_Subscribe_confirm
*/


/*  Link_PDU_Transmit_Status indicates the transmission status of a higher layer PDU by the link layer. A success
status indicates that the higher layer PDU has been successfully delivered from the link layer in the
local node to the link layer in the peer node. */


void Link_PDU_Transmit_Status_indication(
Node*            node,
		LINK_TUPLE_ID*   LinkIdentifier,
		UNSIGNED_INT_2  PacketIdentifier, 
		BOOL         TransmissionStatus/*,
		NodeAddress destinationAddress*/)
		{
 Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
                MIH_PROTOCOL,  
                MSG_MAC_Link_Parameters_Report_indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(PDU_status)); // de declarat in mih_mih_link_sap.h
    PDU_status *stat = (PDU_status *)MESSAGE_ReturnInfo(newMsg);
	if (TransmissionStatus==TRUE)
	    stat->succes=TransmissionStatus;
	if (TransmissionStatus==FALSE)
	    stat->failure=TransmissionStatus;

       //PDU_status->dest=destinationAddress;

//de verificat care e treaba cu packetidentifier

    MESSAGE_Send(node, newMsg, 0);
}


// This primitive returns the result of the query to discover link layer capability 

void Link_Capability_Discover_confirm (
Node*            node,
		STATUS             Status,
		LINK_EVENT_LIST       SupportedLinkEventList,
		LINK_CMD_LIST    SupportedLinkCommandList,
		NodeAddress destinationAddress){
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
                MIH_PROTOCOL,  
                MSG_MAC_Link_Capability_Discover_confirm);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_list));
    link_list *list = (link_list *)MESSAGE_ReturnInfo(newMsg);
	
	list->status=Status;

//	if (LINK_EVENT_LIST !=0)
	    list->l_ev_list = SupportedLinkEventList ;
//	if (LINK_CMD_LIST !=0)
	    list->l_cmd_list = SupportedLinkEventList ;

	list->dest = destinationAddress;

    MESSAGE_Send(node, newMsg, 0);
}

//cum e cu if la link event si cmd list?


//This primitive returns the result of the subscription request.

void Link_Event_Subscribe_confirm(
Node*            node,
		STATUS             Status,
		LINK_EVENT_LIST       ResponseLinkEventList,
		NodeAddress destinationAddress){
 Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
                MIH_PROTOCOL,  
                MSG_MAC_Link_Event_Subscribe_confirm);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(ev_list));
    ev_list *listev = (ev_list *)MESSAGE_ReturnInfo(newMsg);
	
	listev->status=Status;
	
//	if (LINK_EVENT_LIST !=0)
	    listev->l_ev_list = ResponseLinkEventList ;

	listev->dest=destinationAddress;
	
    MESSAGE_Send(node, newMsg, 0);
}




/*MIRCEA BUGA*/


/* to be included in api.h:
MSG_MAC_Link_Going_Down_Indication
MSG_MAC_Link_Handover_Iminent_indication
MSG_MAC_Link_Handover_Complete_indication

 */


/*event: Link conditions are degrading and connection loss is
imminent.
This notification is delivered when a Layer 2 connection is expected (predicted) to go down (Link_Down)
within a certain time interval. Link_Going_Down event may be the indication to initiate handover procedures. */

void Link_Going_Down_indication(
								Node* node,
								LINK_TUPLE_ID*  LinkIdentifier,
								UNSIGNED_INT_2	TimeInterval, 
								LINK_GD_REASON  LinkGoingDownReason /*,
								NodeAddress destinationAddress */)
{
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
               MIH_PROTOCOL/*MIH_PROTOCOL is seen by the Mac_layer as a protocol of layer 3 and by the network_layer as a protocol of layer 2  */,  
                MSG_MAC_Link_Going_Down_Indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(down_reason));
    down_reason *reason = (down_reason *)MESSAGE_ReturnInfo(newMsg);
	
	reason->linkId = LinkIdentifier;
	reason->timeInt = TimeInterval;
	reason->lgdReason = LinkGoingDownReason;
	
	reason->srcMihfID = node->nodeId;

    MESSAGE_Send(node, newMsg, 0);
}


/*Link_Handover_Imminent is generated when a native link layer handover or switch decision has been made
and its execution is imminent (as opposed to Link_Going_Down which only indicates that a link is losing
connectivity due to a change in a certain link condition such as signal strength, but does not guarantee that
an autonomous link switch-over has been decided by the link layer). It contains information about the new
point of attachment of the MN (the LinkIdentifier parameter contains information about the new PoA). This
is a link layer event that exists for intra-technology handovers defined in many media types.*/

void Link_Handover_Iminent_indication(
Node*            node,
		LINK_TUPLE_ID*    OldLinkIdentifier,
		LINK_TUPLE_ID*    NewLinkIdentifier,
		LINK_ADDR*        OldAccessRouter,
		LINK_ADDR*        NewAccessRouter/*,
		NodeAddress destinationAddress*/)
{
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
               MIH_PROTOCOL/*MIH_PROTOCOL is seen by the Mac_layer as a protocol of layer 3 and by the network_layer as a protocol of layer 2  */,  
                MSG_MAC_Link_Handover_Iminent_indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_charc_im/*trebuie definit*/));
    link_charc_im *charc_comp = (link_charc_im *) MESSAGE_ReturnInfo(newMsg);
	
    charc_comp->NewAccessRouter=NewAccessRouter;
	charc_comp->NewLinkIdentifier=NewLinkIdentifier;
	charc_comp->OldAccessRouter=OldAccessRouter;
	charc_comp->OldLinkIdentifier=OldLinkIdentifier;

	
    MESSAGE_Send(node, newMsg, 0);
}


void Link_Handover_Complete_indication(
Node*            node,
		LINK_TUPLE_ID*    OldLinkIdentifier,
		LINK_TUPLE_ID*    NewLinkIdentifier,
		LINK_ADDR*        OldAccessRouter,
		LINK_ADDR*        NewAccessRouter ,
		STATUS           LinkHandoverStatus/*,
		NodeAddress destinationAddress*/){
	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               NETWORK_LAYER,
               MIH_PROTOCOL/*MIH_PROTOCOL is seen by the Mac_layer as a protocol of layer 3 and by the network_layer as a protocol of layer 2  */,  
                MSG_MAC_Link_Handover_Complete_indication);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_charc_comp/*trebuie definit*/));
    link_charc_comp *charc_comp = (link_charc_comp *)MESSAGE_ReturnInfo(newMsg);
	charc_comp->LinkHandoverStatus=LinkHandoverStatus;
	charc_comp->NewAccessRouter=NewAccessRouter;
	charc_comp->NewLinkIdentifier=NewLinkIdentifier;
	charc_comp->OldAccessRouter=OldAccessRouter;
	charc_comp->OldLinkIdentifier=OldLinkIdentifier;
    MESSAGE_Send(node, newMsg, 0);
}



/*CATALINA PENCIU*/

/*to be included in api.h: 
MSG_MAC_Event_Unsubscribe_confirm
MSG_MAC_Get_Parameters_confirm
MSG_MAC_Link_Configure_Thresholds_confirm
MSG_MAC_Link_Action_confirm;*/



/*This primitive returns the result of the request to unsubscribe from receiving link layer event notifications,generated in response to a Link_Event_Unsubscribe.request primitive.*/
	
	void Link_Event_Unsubscribe_confirm(
		Node* node,
		STATUS Status,
		LINK_EVENT_LIST       ResponseLinkEventList,
		NodeAddress destinationAddress)
	{
	
		Message* newMsg;
    	newMsg = MESSAGE_Alloc(node,
               	NETWORK_LAYER,
              	MIH_PROTOCOL,  
                MSG_MAC_Event_Unsubscribe_confirm);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_unsub));
    link_unsub *unsub = (link_unsub *)MESSAGE_ReturnInfo(newMsg);
	
	unsub->status=Status;
	unsub->events=ResponseLinkEventList;
	unsub->dest=destinationAddress;

	MESSAGE_Send(node, newMsg, 0);
};



/*This primitive is sent in response to the Link_Get_Parameters.request primitive. This primitive provides
current value of the requested link parameters*/


void Link_Get_Parameters_confirm(Node* node,
									 STATUS Status,
									 l_LINK_PARAM* LinkParametersStatusList,
									 l_LINK_STATES_RSP* LinkStatesResponse,
									 l_LINK_DESC_RSP* LinkDescriptorsResponse,
									 NodeAddress destMihfID,
									 NodeAddress srcMihfID,
									 int transactionId,
									 clocktype transactionInitiated)
{
	Message* newMsg;
	newMsg = MESSAGE_Alloc(node,
               	NETWORK_LAYER,
              	MIH_PROTOCOL,  
                MSG_MAC_Get_Parameters_confirm);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(link_params));
    link_params *l_param = (link_params *)MESSAGE_ReturnInfo(newMsg);

	l_param->status = Status;
	l_param->linkParamStatusList = LinkParametersStatusList;
	l_param->linkStatesRsp = LinkStatesResponse;
	l_param->linkDescRsp = LinkDescriptorsResponse;
	l_param->destMihfID = destMihfID; //the MIHF ID of the mobile node for which we want parameters
	l_param->srcMihfID = srcMihfID; //the source of this confirm primitive i.e. this nodeId
	l_param->transactionId = transactionId;
	l_param->transactionInitiated = transactionInitiated;

	MESSAGE_Send(node, newMsg, 0);
};

/*This primitive is sent in response to the Link_Configure_Thresholds.request primitive. This primitive specifies
the status of threshold configuration operation.
The recipient prepares to receive Link_Parameters_Report indications on successful execution of this primitive.
However, if Status does not indicate ���Success���, the recipient performs appropriate error handling.*/

void Link_Configure_Thresholds_confirm(Node* node,
									   STATUS Status,
									   L_LINK_CFG_STATUS* LinkConfigureStatusList /*,
									   NodeAddress destinationAddress */)
{

	Message* newMsg;
    newMsg = MESSAGE_Alloc(node,
               	NETWORK_LAYER,
              	MIH_PROTOCOL,  
                MSG_MAC_Link_Configure_Thresholds_confirm);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(config_thresh));
    config_thresh *config = (config_thresh *)MESSAGE_ReturnInfo(newMsg);

	config->LinkConfigureStatusList=LinkConfigureStatusList;
	config->Status=Status;


	MESSAGE_Send(node, newMsg, 0);
};



/*This primitive is used by link layer technologies to provide an indication of the result of the action executed
on the current link layer connection.
Effect:Upon receipt of this primitive, the MIHF determines the relevant MIH command that needs to be used to
provide an indication or confirmation to the MIH User of the actions performed on the current link layer
connection. If a Scan action was issued by the associated Link_Action.request, the optional ScanResponseSet
field is included in the Link_Action.confirm response.*/	
	
	void Link_Action_confirm(
Node*            node,
		STATUS                Status,
		L_LINK_SCAN_RSP*       ScanResponseSet,
		LINK_AC_RESULT        LinkActionResult /*, 
		NodeAddress destinationAddress*/)
	{

	Message* newMsg;
    	newMsg = MESSAGE_Alloc(node,
               	NETWORK_LAYER,
              	MIH_PROTOCOL,  
                MSG_MAC_Link_Action_confirm);

    MESSAGE_InfoAlloc(node, newMsg, sizeof(action_conf));
    action_conf *confirm = (action_conf *)MESSAGE_ReturnInfo(newMsg);

	confirm->Status=Status;
	confirm->LinkActionResult=LinkActionResult;
	confirm->ScanResponseSet=ScanResponseSet;
	//confirm->dest=destinationAddress;

	MESSAGE_Send(node, newMsg, 0);
};


/*OANA BARBU*/
/*This primitive is used by the MIHF to query and discover the list of supported link layer events and link
layer commands.
This primitive is generated by the MIHF when it needs to receive link layer event notifications and learn
about which link layer commands the lower layer can support*/

void Link_Capability_Discover_request (Node *node,
									   NodeAddress destinationAddress){

Message* newMsg;
	newMsg = MESSAGE_Alloc(node,
				MAC_LAYER,
				INTEROPERABILITY_MODULE,  //the protocol at mac_layer seen from  interoperability_module
				MSG_Link_Capability_Discover_request);
	 MESSAGE_InfoAlloc(node, newMsg, NULL);
    
	MESSAGE_Send(node, newMsg, 0);
};


/*BOGDAN CIOBOTARU*/

/*to be included in api.h:
MSG_Link_Get_Parameters_request
MSG_Link_Configure_Thresholds_request*/

/*This primitive is used by the MIHF to obtain the current value of a set of link parameters of a specific link.*/

void Link_Get_Parameters_request(Node *node,
		L_LINK_PARAM_TYPE*     LinkParametersRequest,
		LINK_STATES_REQ       LinkStatesRequest,
		LINK_DESC_REQ         LinkDescriptorsRequest,
		NodeAddress srcMihfID,
		int transactionId,
		clocktype transactionInitiated)
{
	Message* newMsg;
	newMsg = MESSAGE_Alloc(node,
				MAC_LAYER,
				INTEROPERABILITY_MODULE,  //the protocol at mac_layer seen from  interoperability_module
				MSG_Link_Get_Parameters_request);
	MESSAGE_InfoAlloc(node, newMsg, sizeof(local_link_parameters));
    local_link_parameters *param_req = (local_link_parameters *)MESSAGE_ReturnInfo(newMsg);

	param_req->linkParamReq  = LinkParametersRequest;
	param_req->linkStatesReq = LinkStatesRequest; //bitmap_16
    param_req->linkDescReq = LinkDescriptorsRequest; // A set of link descriptors  Bit 0: Number of Classes of Service Supported
                                           // Bit 1: Number of Queues Supported   Bits 2-15: (Reserved)
	param_req->srcMihfID = srcMihfID;
	param_req->transactionId = transactionId;
	param_req->transactionInitiated = transactionInitiated;
	MESSAGE_Send(node, newMsg, 0); 
};

/*This primitive is used by the MIHF to configure thresholds and/or specify the time interval between periodic
reports for the Link_Parameters_Report indication.*/

void Link_Configure_Thresholds_request(
 Node *node,
L_LINK_CFG_STATUS*     LinkConfigureStatusList)
{
Message* newMsg;
	newMsg = MESSAGE_Alloc(node,
				MAC_LAYER,
				INTEROPERABILITY_MODULE,  //the protocol at mac_layer seen from  interoperability_module
				MSG_Link_Configure_Thresholds_request);
MESSAGE_InfoAlloc(node, newMsg, sizeof(L_LINK_CFG_STATUS));
    
	L_LINK_CFG_STATUS* list=(L_LINK_CFG_STATUS *)MESSAGE_ReturnInfo(newMsg);
	list=LinkConfigureStatusList;

MESSAGE_Send(node, newMsg, 0);
};


/*MIRCEA BUGA */
/*to be included in api.h:
MSG_Link_Event_Subscribe_request
MSG_Link_Event_Unsubscribe_request*/



/*This primitive is used by MIHF (the subscriber) to subscribe an interest in one or more events from a specific
link layer technology. The response indicates which of the requested events were successfully subscribed
to. Events that were not successfully subscribed to will not be delivered to the subscriber.*/

void Link_Event_Subscribe_request(
								   Node *node,
		LINK_EVENT_LIST* RequestedLinkEventList)
{
Message* newMsg;
	newMsg = MESSAGE_Alloc(node,
				MAC_LAYER,
				INTEROPERABILITY_MODULE,  //the protocol at mac_layer seen from  interoperability_module
				MSG_Link_Event_Subscribe_request);
MESSAGE_InfoAlloc(node, newMsg, sizeof(subscribe_event/*trebuie definit*/));
    subscribe_event *events = (subscribe_event *)MESSAGE_ReturnInfo(newMsg);

	events->list= RequestedLinkEventList;
MESSAGE_Send(node, newMsg, 0);
};



/*This primitive is used by the MIHF (the subscriber) to unsubscribe from a set of previously subscribed link
layer events.*/

void Link_Event_Unsubscribe_request(
									 Node *node,
		LINK_EVENT_LIST* RequestedLinkEventList)
{
Message* newMsg;
	newMsg = MESSAGE_Alloc(node,
				MAC_LAYER,
				INTEROPERABILITY_MODULE,  //the protocol at mac_layer seen from  interoperability_module
				MSG_Link_Event_Unsubscribe_request);
MESSAGE_InfoAlloc(node, newMsg, sizeof(subscribe_event/*trebuie definit*/));
    unsubscribe_event *events = (unsubscribe_event *)MESSAGE_ReturnInfo(newMsg);

	events->list=RequestedLinkEventList;
MESSAGE_Send(node, newMsg, 0);
};

/*CATALINA PENCIU*/


/*This primitive is used by the MIHF to request an action on a link layer connection to enable optimal handling
of link layer resources for the purpose of handovers. The link layer connection can be ordered, e.g. to
shut down, to remain active, to perform a scan, or to come up active and remain in stand-by mode. The command
execution delay time can also be specified for cases where the link layer technology under consideration
supports the action.
Effect: Upon receipt of this primitive, the link layer technology supporting the current link layer connections performs
the action specified by the Link Action parameter in accordance with the procedures specified by the
relevant standards organization and at the time specified by the Execution Delay parameter.*/

void Link_Action_request( Node *node,
		NodeAddress destAddr,
		LINK_ACTION* LinkAction,
		UNSIGNED_INT_2 ExecutionDelay,
		LINK_ADDR*  PoALinkAddress )
{
	switch (PoALinkAddress->selector)
	{
	case 0: // 802
		{
			for (int i = 0; i<node->numberInterfaces; i++)
				if (node->macData[i]->macProtocol == MAC_PROTOCOL_DOT11) //has to be rewritten to address more general case
				{
					Message* newMsg;
					newMsg = MESSAGE_Alloc(node,
               					MAC_LAYER,
              					node->macData[i]->macProtocol,   
								MSG_MAC_Link_Action_request);

					MESSAGE_SetInstanceId(newMsg, i);

					MESSAGE_InfoAlloc(node, newMsg, sizeof(action_req));
					action_req *req = (action_req *)MESSAGE_ReturnInfo(newMsg);

					req->mobileNodeId = destAddr;
					req->LinkAction=LinkAction;
					req->ExecutionDelay=ExecutionDelay;
					req->PoALinkAddress=PoALinkAddress;
					MESSAGE_Send(node, newMsg, 0);
				}
			break;
		}
	case 1: // 3GPP
		{
			Message* newMsg;
			newMsg = MESSAGE_Alloc(node,
               			NETWORK_LAYER,
              			NETWORK_PROTOCOL_CELLULAR,   //doesn't matter, it will end up at the default protocol anyway
						MSG_MAC_Link_Action_request);

			MESSAGE_InfoAlloc(node, newMsg, sizeof(action_req));
			action_req *req = (action_req *)MESSAGE_ReturnInfo(newMsg);

			req->mobileNodeId = destAddr;
			req->LinkAction=LinkAction;
			req->ExecutionDelay=ExecutionDelay;
			req->PoALinkAddress=PoALinkAddress;
			MESSAGE_Send(node, newMsg, 0);
			break;
		}
	default:
		{
			return;
		}
	}

	
};










